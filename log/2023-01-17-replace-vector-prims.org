#+title: Replace Vector Prims
#+date: <2023-01-17 15:00>
#+description: A quick and hopefully temporary shim to treat other things as vectors.
#+filetags:

To make =stage0= for Gerbil work in JavaScript we will try and fudge the ##vector-* usage.

* Gerbil Subtree

Ideally almost all of this gets pushed back into Gerbil. For now we make a subtree.

#+begin_src sh
  git remote add gerbil git@github.com:drewc/gerbil.git
  git fetch gerbil
  git subtree add --prefix=gerbil gerbil master
#+end_src

* Gambit Submodulr

We may require Gambit things/patches/etc. Gambit likes a git to build


#+begin_src sh
  git submodule add git@github.com:drewc/gambit.git
  cd gambit
  git remote add gambit git@github.com:gambit/gambit.git
  git fetch gambit --tags
  git push
#+end_src

** Build what's needed in Gambit

#+begin_src sh
  cd gambit
  ./configure --prefix=$(pwd) --enable-single-host \
              --enable-default-compile-options="(compactness 0)"
  make clean
  make -j8 core
  make _gambit.js

  gsc/gsc -:= -target js -exe -o bin/gsi-js -prelude "(##include\"../lib/header.scm\")" gsi/_gsi.js

  #$ ./gsi-js
#+end_src

* Gerbil =stage0= bootstrap

Gerbil, like almost all lisps, is developed in itself using itself. But the main scheme it transpiles towards is Gambit. Rather than require itself to build itself Gerbil uses a bootstrapped Gerbil runtime developed in Gambit kinda/sorta.

In the upstream it currently uses =##vector-ref= and other vector friends where it actually wants a structure ref or a values ref. This is because they are the same for the C thingie. But not for the Universal thingie.

We're going to create a =%%structor-ref=, along with a =_gx#structor-ref=, with their friends tagging along, and see how that goes.


** The maybe-used syntax in =gx-gambc#=

: ;;; shims to ensure inlining of low level primitives

We hope that these are no longer used, but we've made them fudge a little.

#+begin_src scheme :noweb-ref %%vectors
(define-macro (%%vector-ref v pos)
  `(let ((v ,v) (pos ,pos))
     (declare (not safe))
     (if (##vector? v)
         (##vector-ref v pos)
         (error "Attempting ##vector-ref on non-vector:" v))))
(define-macro (%%vector-set! v pos val)
  `(let ((v ,v) (pos ,pos) (val ,val))
     (declare (not safe))
     (if (##vector? v)
         (##vector-set! v pos val)
         (error "Attempting ##vector-set! on non-vector:" v))))
(define-macro (%%vector-length v)
  `(let ((v ,v))
     (declare (not safe))
     (if (##vector? v)
         (##vector-length v)
         (error "Tried ##vector-length on a non-vector:" v))))
#+end_src

Now, to "recreate": them with as little work as possible we'll create some new syntax based on our new type, =structor=.

#+begin_src scheme :noweb-ref %%vectors
  ;;; shims that pretend structs are vectors : structor
  (define-macro (%%structor-ref obj i)
    `(let ((obj ,obj))
       (declare (not safe))
       (if (##structure? obj)
           (##unchecked-structure-ref obj ,i ##type-type #f)
           (error "Tried %%structor-ref on non structure:" obj))))
  ;;; Structures and vectors reverse /obj/ and /i/.
  (define-macro (%%structor-set! obj i val)
    `(let ((obj ,obj))
       (declare (not safe))
       (if (##structure? obj)
           (##unchecked-structure-set! obj ,val ,i ##type-type #f)
           (error "Tried %%structor-set! on non-structure: " obj))))
  (define-macro (%%structor-length obj)
    `(let ((obj ,obj)) (declare (not safe))
          (if (##structure? obj)
              (##structure-length obj)
              (error "Tried %%structor-length on non-structure:" obj))))
  ;;; / end structor
#+end_src

*** Change the library lookup path

In testing this we discover the first issue that we already know about.

#+begin_src sh
  > export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
  > $GERBIL_GSI ./gx-gambc#.scm
   ,*** ERROR IN "gx-gambc#.scm"@5.1 -- Can't open file "/usr/local/Gambit/lib/_gambit#.scm"
#+end_src

That's an interesting prefix as I thought we'd set it.

#+begin_src sh :session stage0 :results verbatim :wrap src js
  export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js

  grep -i "/usr/local/Gambit" $GERBIL_GSI;
#+end_src
*=>*
#+begin_src js
return _host2scm('/usr/local/Gambit/');
#+end_src

Ok, that's not bad. Let's simply replace it with our gambit directory.

#+begin_src sh :session stage0 :results verbatim :wrap src js
  export JS_GAMBIT_HOME=~/me/MuKn/src/gerbil.js/gambit
  SEDME="s|/usr/local/Gambit/|$JS_GAMBIT_HOME/|g"

  sed -i $SEDME $GERBIL_GSI
#+end_src

Now?
#+begin_src sh :session stage0 :results verbatim :wrap src js
  grep -i $JS_GAMBIT_HOME $GERBIL_GSI
#+end_src
*=>*
#+begin_src js
return _host2scm('/home/drewc/me/MuKn/src/gerbil.js/gambit/');
#+end_src


And finally.

#+begin_src sh :results verbatim :wrap example
        export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
        export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil
        $GERBIL_GSI -e "(begin
          (include \"$GERBIL_SRC/src/gerbil/runtime/gx-gambc#.scm\")
          (display (%%vector-ref (##vector \"Hey!\n\") 0))
          (display (%%structor-ref (##structure \"You!\") 0)))"
#+end_src
*=>*
#+begin_example
Hey!
You!
#+end_example


** The runtime! =gx-gambc0=

In this file there are many uses of =%%vector-= macros.

#+begin_src sh :results verbatim :wrap example
  export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
  export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil

  cd $GERBIL_SRC/src/gerbil/runtime
  $GERBIL_GSI -e '(include "./gx-gambc#.scm")' ./gx-gambc0.scm
#+end_src
*=>*
#+begin_example
,*** ERROR IN gerbil-runtime-smp?, "gx-gambc0.scm"@34.8 -- Attempting ##vector-ref on non-vector: #<thread-group #2 primordial>
>
,*** EOF again to exit
#+end_example


We'll get rid of them.


#+begin_src sh :results verbatim :wrap src js
  export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil
  export GX0=$GERBIL_SRC/src/gerbil/runtime/gx-gambc0.scm
  SEDME="s|%%vector|%%structor|g"

  echo "Sed'ing $GX0"
  sed -i $SEDME $GX0
#+end_src

#+RESULTS:
#+begin_src js
Sed'ing /home/drewc/me/MuKn/src/gerbil.js/gerbil/src/gerbil/runtime/gx-gambc0.scm
#+end_src

Now?
#+begin_src sh :results verbatim :wrap example
  export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
  export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil

  cd $GERBIL_SRC/src/gerbil/runtime
  $GERBIL_GSI -e '(include "./gx-gambc#.scm")' ./gx-gambc0.scm\
              -e '(displayln "Try out error? " (error? (##structure error::t)))'
#+end_src

#+RESULTS:
#+begin_example
Try out error? #t
#+end_example

** =gx-gambc1=, gerbil ASTs and a primitive eval.

In =gambc0= we defined a MOP and an object system along with a minimal scheme system with functions needed for the rest.

Now we'll use it to define an AST. We just need to switch vectors to structs again.

#+begin_src sh :results verbatim :wrap src diff
  export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil
  cd $GERBIL_SRC/src/gerbil/runtime
  git diff 2d8c03 gx-gambc1.scm
#+end_src
*=>*
#+begin_src diff
diff --git a/gerbil/src/gerbil/runtime/gx-gambc1.scm b/gerbil/src/gerbil/runtime/gx-gambc1.scm
index 95bd6215..dd569a4d 100644
--- a/gerbil/src/gerbil/runtime/gx-gambc1.scm
+++ b/gerbil/src/gerbil/runtime/gx-gambc1.scm
@@ -22,10 +22,10 @@
   `(##structure-instance-of? ,e 'gerbil#AST::t))

 (define-macro (%AST-e e)
-  `(##vector-ref ,e 1))
+  `(##unchecked-structure-ref ,e 1 AST::t #f))

 (define-macro (%AST-source e)
-  `(##vector-ref ,e 2))
+  `(##unchecked-structure-ref ,e 2 AST::t #f))

 (define (&AST e src-stx)
   (let ((src (&AST-source src-stx)))
@@ -162,9 +162,9 @@
   id: _gx#&context::t)

 (define-macro (%&context-super ctx)
-  `(##vector-ref ,ctx 3))
+  `(##unchecked-structure-ref ,ctx 3 &context::t #f))
 (define-macro (%&context-table ctx)
-  `(##vector-ref ,ctx 4))
+  `(##unchecked-structure-ref ,ctx 4 &context::t #f))

 (define-struct &runtime (id)
   id: _gx#&runtime::t)
@@ -204,12 +204,12 @@
     (macro-readtable-write-extended-read-macros?-set! rt #t)
     (_gx#readtable-bracket-keyword-set! rt '@list)
     (_gx#readtable-brace-keyword-set! rt '@method)
-    (eval-if (>= (##vector-length (current-readtable)) 42)
+    (eval-if (>= (##structure-length (current-readtable)) 42)
       (##readtable-char-sharp-handler-set! rt #\! _gx#read-sharp-bang)
       (void))
     rt))

-(eval-if (>= (##vector-length (current-readtable)) 42)
+(eval-if (>= (##structure-length (current-readtable)) 42)
   (begin
     (define (_gx#readtable-bracket-keyword-set! rt kw)
       (macro-readtable-bracket-handler-set! rt kw))
@@ -1333,7 +1333,9 @@
            (recur rest (fx1+ n))
            (let (($tgt (gensym 'tgt)))
              (&AST
-              `(let-values (((,$tgt) (##vector-ref ,tgt ,n)))
+              `(let-values
+                   (((,$tgt)
+                     (##unchecked-structure-ref ,tgt ,n ##type-type #f)))
                  ,(generate1 hd $tgt (recur rest (fx1+ n)) E))
               stx))))
         (else K)))
@@ -1342,7 +1344,7 @@
            (len (length body)))
       (&AST
        `(if (and (struct-instance? ,type-id ,tgt)
-                 (fx< ,len (##vector-length ,tgt)))
+                 (fx< ,len (##structure-length ,tgt)))
           ,(recur body 1)
           ,E)
        stx)))
#+end_src

*** Primitive ~eval~

Gerbil has, well:

#+begin_quote
 This is a primitive eval that can be used to bootstrap the Gerbil expander directly from source (without an expander bootstrap).  It was used in early Gerbil, and could be used again if you want to (painfully) bootstrap the expander from source again, perhaps for trust purposes.
#+end_quote

Because we are a few files before the expander bootstrap having a working Gerbil is not a bad idea.

#+begin_src scheme :tangle test-gambc1.scm
  (displayln "This is a test for gx-gambc1: The AST")
  (define syns (read-syntax-from-file "./gx-version.scm"))
  (display* "Have Syntax: " syns "which prints as\n\t")
  (map _gx#pp-syntax syns)
  (define (text-gvs) "0.17.0-666-hahaha")
  (displayln "What is here? :" &context::t " and " _gx#eval)
#+end_src

*Gerbil* has =cond-expand gerbil-bootstrap-expander= so we need to define it. When we have that defined there is a ~_gx#eval~ that needs a compiler. We don't yet have that so onto =gx-gambc2=
#+begin_src sh :results verbatim :wrap example
      export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
      export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil


      PRELUDE="(define-cond-expand-feature|gerbil-bootstrap-expander|)"

      testfile=$(pwd)/test-gambc1.scm

      cd $GERBIL_SRC/src/gerbil/runtime

      $GERBIL_GSI -e $PRELUDE -e '(include "./gx-gambc#.scm")' \
                  ./gx-gambc0.scm ./gx-gambc1.scm\
                  $testfile
#+end_src

#+RESULTS:
#+begin_example
This is a test for gx-gambc1: The AST
Have Syntax: (#<syntax #2>)which prints as
(define (gerbil-version-string) "0.17.0-66-g605e6fd6")
	What is here? :#<type #3 &context> and #<procedure #4 _gx#eval>
#+end_example

** =gx-gambc2=, the compiler


#+begin_src scheme :tangle test-gambc2.scm
  (displayln "This is a test for gx-gambc2: The compiler")
  (define syns (read-syntax-from-file "./gx-version.scm"))
  (display* "Have Syntax: " syns "which prints as\n\t")
  (map _gx#pp-syntax syns)
  (define (text-gvs) "0.17.0-666-hahaha")
  (displayln "What is here? :" &context::t " and " _gx#eval
             "\n\tand finally " _gx#compile "in)
  (display (map _gx#compile syns))
#+end_src
#+begin_src sh :results verbatim :wrap example
      export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
      export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil


      PRELUDE="(define-cond-expand-feature|gerbil-bootstrap-expander|)"

      testfile=$(pwd)/test-gambc2.scm

      cd $GERBIL_SRC/src/gerbil/runtime

      $GERBIL_GSI -e $PRELUDE -e '(include "./gx-gambc#.scm")' \
                  ./gx-gambc0.scm ./gx-gambc1.scm ./gx-gambc2.scm \
                  $testfile
#+end_src

#+RESULTS:
#+begin_example
This is a test for gx-gambc2: The compiler
Have Syntax: (#<syntax #2>)which prints as
(define (gerbil-version-string) "0.17.0-66-g605e6fd6")
	What is here? :#<type #3 &context> and #<procedure #4 _gx#eval>
	and finally #<procedure #5 _gx#compile>
,*** ERROR IN map -- This object was raised: #<syntax-error #6>
>
,*** EOF again to exit
#+end_example

* =find ./bootstrap -name '*.scm'=, the boostraped expander/compiler

In this case there's a sh1t3l0ad of =##vector-*= usage that, again, we do not want.

Most of the time it's a struct, some of the time it's a ~values~, or at least that knowledge is from past lookie-loos, so for now we'll just make some of our own.

We'll also put in on the top of gambc2 as ~(define-macro (%&syntax-e obj) ...)~ is suspicious.

  1) =s/##vector-ref/_gx#vector-ref/g=
     #+begin_src scheme :noweb-ref _gx#vector
       (define (_gx#vector-ref svs n)
         (if (##structure? svs)
             (##unchecked-structure-ref svs n ##type-type _gx#vector-ref)
             (if (##values? svs)
                 (##values-ref svs n)
                 (if (##vector? svs)
                  (##vector-ref svs n)
                  (error "Tried _gx#vector-ref on a non-vector/struct/values: " svs)))))
     #+end_src

  2) =s/##vector-set!/_gx#vector-set!/g=

     #+begin_src scheme :noweb-ref _gx#vector
       (define (_gx#vector-set! svs i value)
         (if (##structure? svs)
             (##unchecked-structure-set!
              svs value i ##type-type _gx#vector-set!)
             (if (##values? svs)
                 (##values-set! svs i value)
                 (if (##vector? svs)
                  (##vector-set! svs i value)
                  (error "Tried _gx#vector-set! on a non-vector/struct/values: " svs)))))
     #+end_src

  3) =s/##vector-length/_gx#vector-length/g=

     #+begin_src scheme :noweb-ref _gx#vector
       (define (_gx#vector-length svs)
         (if (##structure? svs) (##structure-length svs)
             (if (##values? svs) (##values-length svs)
                 (if (##vector? svs) (##vector-length svs)
                  (error "Tried _gx#vector-length on a non-vector/struct/values: " svs)))))
     #+end_src

  4) =s/##vector->list/_gx#vector->list/g=

     #+begin_src scheme :noweb-ref _gx#vector
       (define (_gx#vector->list svs)
         (if (##vector? svs)
             (##vector->list svs)
             (if (##structure? svs)
                 (let ((end (##structure-length svs)))
                   (let sl ((n 0))
                     (if (= n end) '()
                         (cons (##unchecked-structure-ref
                                svs n ##type-type _gx#vector->list)
                               (sl (+ 1 n))))))
                 (if (##values? svs) (##values->list svs)
                     (error "Tried _gx#vector->list on a non-vector/struct/values: " svs)))))
     #+end_src

** test them


#+begin_src scheme :tangle test-gx-vector.scm
   (displayln "This is a test for _gx#vector-* things")
   (define gxvec (##vector 1 2 42))
   (define gxstruct (##structure ##type-type 1 2 42))
   (define gxvals (##values 1 2 42))
   (define gxlist (list 1 2 3))
   (display*
    "Vector: " gxvec " answer " (_gx#vector-ref gxvec 2)
     " len " (_gx#vector-length gxvec))
   (display* "\n\tSet " (_gx#vector-set! gxvec 2 3))
   (display* "\n\t ->list equal to " gxlist "? "
    (equal? (_gx#vector->list gxvec) gxlist))
  (display*
     "\n\nStruct: " gxstruct " answer " (_gx#vector-ref gxstruct 3)
      " len " (_gx#vector-length gxstruct))
  (display* "\n\tSet " (_gx#vector-set! gxstruct 3 3))
   (display* "\n\t cdr ->list equal to " gxlist "? "
    (equal? (cdr (_gx#vector->list gxstruct)) gxlist))
  (display*
   "\n\nValues: " gxvals " answer " (_gx#vector-ref gxvals 2)
   " len " (_gx#vector-length gxvals))
  (display* "\n\tSet " (_gx#vector-set! gxvals 2 3))
  (display* "\n\t  ->list equal to " gxlist "? "
   (equal? (_gx#vector->list gxvals) gxlist))

  #+end_src


  #+begin_src sh :results verbatim :wrap example
    export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
    export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil


    PRELUDE="(define-cond-expand-feature|gerbil-bootstrap-expander|)"

    testfile=$(pwd)/test-gx-vector.scm

    cd $GERBIL_SRC/src/gerbil/runtime

    $GERBIL_GSI -e $PRELUDE -e '(include "./gx-gambc#.scm")' \
                ./gx-gambc0.scm ./gx-gambc1.scm ./gx-gambc2.scm \
                $testfile
#+end_src
#+begin_example
This is a test for _gx#vector-* things
Vector: #(1 2 42) answer 42 len 3
	Set #(1 2 3)
	 ->list equal to (1 2 3)? #t

Struct: #<type #2 2> answer 42 len 4
	Set #<type #2 2>
	 cdr ->list equal to (1 2 3)? #t

Values: #<unknown> answer 42 len 3
	Set #<unknown>
	  ->list equal to (1 2 3)? #t
#+end_example

** Sed the bootstrap

#+begin_src sh :results verbatim :wrap example
  export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil
  StarSed() {
      echo "s/##vector-$1/_gx#vector-$1/g"
  }
  cd $GERBIL_SRC/src/bootstrap/
  find . -name "*.scm" -exec sed -i "$(StarSed ref)" {} \;
  find . -name "*.scm" -exec sed -i "$(StarSed set!)" {} \;
  find . -name "*.scm" -exec sed -i "$(StarSed length)" {} \;
  find . -name "*.scm" -exec sed -i "$(StarSed '>list')" {} \;
#+end_src

#+RESULTS:
#+begin_example
#+end_example

  #+begin_src sh :results verbatim :wrap example
    export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil
    export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
    cd $GERBIL_SRC/src/gerbil/runtime

    PRELUDE="(define-cond-expand-feature|gerbil-bootstrap-expander|)"

    testfile=$(pwd)/test-gx-vector.scm


    $GERBIL_GSI -e $PRELUDE -e '(include "./gx-gambc#.scm")' \
                ./gx-gambc0.scm ./gx-gambc1.scm ./gx-gambc2.scm \
                $testfile
#+end_src


* Attempt a new build

First the =runtime/build.scm= needs some work.

#+begin_src scheme :noweb-ref runtime-build-main
  (define (main libdir)
  (displayln "building gerbil/runtime in " libdir)
  (update-gx-version)
  (parallel-build
   ,*gx-modules*
   (compiler `("-o" ,libdir
               "-target" "js"
          ;;     "-cc-options" "--param max-gcse-memory=300000000"
          ;;     ,@(if (runtime-smp?)
          ;;       '("-e" "(define-cond-expand-feature|enable-smp|)")
          ;;       '())
               "-e" "(include \"gx-gambc#.scm\")"))
   false))
#+end_src

 Then the =build0.= Change to a javascript target.

#+HEADER: :tangle ~/me/MuKn/src/gerbil.js/gerbil/src/build/build0.scm
#+begin_src scheme
    (##namespace (""))

    (load "gerbil/runtime/build-lib.scm")

    (parallel-build
     (call-with-input-file ".build.stage0" read-all-as-lines)
     (compiler ;; '("-cc-options" "--param max-gcse-memory=300000000")
      '("-target" "js"))
     false)
#+end_src

And build!

  #+begin_src sh :results verbatim :wrap example
        export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
        export GERBIL_GSC=~/me/MuKn/src/gerbil.js/gambit/gsc/gsc
        export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil

        cd $GERBIL_SRC/src/ && ./build.sh gxi
        cd $GERBIL_SRC/src/ && ./build.sh stage0

        export GERBIL_HOME=$GERBIL_SRC/bootstrap

        exec 2>&1
          $GERBIL_HOME/bin/gxi -e '(display* "The Answer to LTUAE is?" 42)' || echo foo
#+end_src

Test?
  #+begin_src sh :results verbatim :wrap example
    export GERBIL_GSI=~/me/MuKn/src/gerbil.js/gambit/bin/gsi-js
    export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil
    export GERBIL_HOME=$GERBIL_SRC/bootstrap

    $GERBIL_HOME/bin/gxi -e '(display* "The Answer to LTUAE is?" 42)' 2>&1 || true




#+end_src
*=>*
#+begin_example
/home/drewc/me/MuKn/src/gerbil.js/gerbil/bootstrap/lib/gx-gambc1.o1:965
    return _apply3();
    ^

ReferenceError: _apply3 is not defined
    at _bb56_gx_2d_gambc1_23_ (/home/drewc/me/MuKn/src/gerbil.js/gerbil/bootstrap/lib/gx-gambc1.o1:965:5)
    at _bb54_gx_2d_gambc1_23_ (/home/drewc/me/MuKn/src/gerbil.js/gerbil/bootstrap/lib/gx-gambc1.o1:942:10)
    at _trampoline (/home/drewc/me/MuKn/src/gerbil.js/gambit/bin/gsi-js:910:10)
    at callback (/home/drewc/me/MuKn/src/gerbil.js/gambit/bin/gsi-js:11745:11)
    at FSReqCallback.oncomplete (node:fs:197:23)

Node.js v18.12.0
#+end_example

That's good news as I know those promblems.

* Our own =gsi-js=.
#+HEADER: :tangle ../gerbil/src/gerbil/gsi-js.scm
#+begin_src scheme
(##include "~~lib/header.scm")
(##include "~~gsi/_gsi.scm")

(define (%dummy arg . args)
  (##apply arg 1 args)
  (##apply arg 1 2 args)
  (##apply arg 1 2 3 args)
  (##apply arg 1 2 3 4 args)
  (##apply arg 1 2 3 4 5 args))
#+end_src

  #+begin_src sh :results verbatim :wrap example
    export GAMBIT_SRC=~/me/MuKn/src/gerbil.js/gambit
    export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil

    cd $GERBIL_SRC/src/gerbil && \
        $GAMBIT_SRC/gsc/gsc -target js -exe -o gsi-js ./gsi-js.scm
#+end_src

** Test it
  #+begin_src sh :results verbatim :wrap example
    export GERBIL_SRC=../gerbil
    export GERBIL_GSI=$GERBIL_SRC/src/gerbil/gsi-js
    export GERBIL_HOME=$GERBIL_SRC/bootstrap

    $GERBIL_HOME/bin/gxi -e '(display* "The Answer to LTUAE is?" 42)' 2>&1 || true
#+end_src

*ERROR*

#+begin_example
,*** ERROR IN make-object -- Tried %%structor-set! on non-structure:  #(#f #f #f #f #f #f)
>
,*** EOF again to exit
#+end_example


Seen that before. This is the replacement.

#+begin_src scheme
  (define (make-object klass k)
    (let ((obj (%%make-structure (%%fx+ k 1) #f)))
      (%%unchecked-structure-set! obj klass 0 ##type-type make-object)
      obj))
#+end_src


Now?

  #+begin_src sh :results verbatim :wrap example
        export GERBIL_GSC=~/me/MuKn/src/gerbil.js/gambit/gsc/gsc
        export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil

        cd $GERBIL_SRC/src/ && ./build.sh gxi
        cd $GERBIL_SRC/src/ && ./build.sh stage0
#+end_src

Test it


  #+begin_src sh :results verbatim :wrap example
    export GERBIL_SRC=../gerbil
    export GERBIL_GSI=$GERBIL_SRC/src/gerbil/gsi-js
    export GERBIL_HOME=$GERBIL_SRC/bootstrap

    $GERBIL_HOME/bin/gxi -e '(display* "The Answer to LTUAE is?" 42)' 2>&1 || true
#+end_src
*=> ERROR*
#+begin_example
,*** ERROR IN gx#root-context:::init!__% -- struct-instance-init!: too many arguments for struct #<root-context #2>
>
,*** EOF again to exit
#+end_example

And that's what I thought I'd fixed with all the _gx# shims. Fuck.
#+begin_src sh :results verbatim :wrap example
  find ../gerbil -name '*.scm' -exec grep -Hi 'def.* gx#root-context:::init!__%' {} \;
#+end_src

#+RESULTS:
#+begin_example
../gerbil/src/bootstrap/gerbil/expander/root__0.scm:  (define gx#root-context:::init!__%
../gerbil/bootstrap/lib/gerbil/expander/root__0.scm:  (define gx#root-context:::init!__%
#+end_example

I get it! Finally tracked that down.

#+begin_src scheme
(define (make-object klass k) (%%make-structure klass (%%fx+ k 1)))
#+end_src

#+begin_src sh :results verbatim :wrap example
        export GERBIL_GSC=~/me/MuKn/src/gerbil.js/gambit/gsc/gsc
        export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil

        cd $GERBIL_SRC/src/ && ./build.sh gxi
        cd $GERBIL_SRC/src/ && ./build.sh stage0
#+end_src
Now?
  #+begin_src sh :results verbatim :wrap example
    export GERBIL_SRC=../gerbil
    export GERBIL_GSI=$GERBIL_SRC/src/gerbil/gsi-js
    export GERBIL_HOME=$GERBIL_SRC/bootstrap

    $GERBIL_HOME/bin/gxi -e '(display* "The Answer to LTUAE is?" 42)' 2>&1 || true
#+end_src

#+RESULTS:
#+begin_example
,*** ERROR IN gx#core-bind!__% -- core bond 0
>
,*** EOF again to exit
#+end_example

*=> ERROR*
#+begin_example
,*** ERROR IN gx#core-bind!__% -- (Argument 1) Instance of #<type #2 table> expected
(table-ref 'phi-context 'runtime-type-exhibitor-e #f)
>
,*** EOF again to exit
#+end_example


Well that's new! It seems to be an off by one error.


#+begin_src sh :results verbatim :wrap example
  find ../gerbil -name '*.scm' -exec grep -Hi 'def.* gx#core-bind!__%' {} \;
#+end_src

#+RESULTS:
#+begin_example
../gerbil/src/bootstrap/gerbil/expander/core__0.scm:  (define gx#core-bind!__%
../gerbil/bootstrap/lib/gerbil/expander/core__0.scm:  (define gx#core-bind!__%
#+end_example

#+begin_src sh :results verbatim :wrap example
        export GERBIL_GSC=~/me/MuKn/src/gerbil.js/gambit/gsc/gsc
        export GERBIL_SRC=~/me/MuKn/src/gerbil.js/gerbil

        cd $GERBIL_SRC/src/ && ./build.sh gxi
        cd $GERBIL_SRC/src/ && ./build.sh stage0
 #+end_src
#+begin_src sh :results verbatim :wrap example
    export GERBIL_SRC=../gerbil
    export GERBIL_GSI=$GERBIL_SRC/src/gerbil/gsi-js
    export GERBIL_HOME=$GERBIL_SRC/bootstrap

    $GERBIL_HOME/bin/gxi -e '(display* "The Answer to LTUAE is?" 42)' 2>&1 || true
#+end_src

#+RESULTS:
#+begin_example
,*** ERROR IN gx#core-bind!__% -- (Argument 1) Instance of #<type #2 table> expected
(table-ref 'phi-context 'runtime-type-exhibitor-e #f)
>
,*** EOF again to exit
#+end_example


That will end my adventure today.
* /File/ =runtime/build.scm=

#+HEADER: :tangle ../gerbil/src/gerbil/runtime/build.scm
#+begin_src scheme :noweb yes :shebang #!/usr/bin/env gsi-script
  (##namespace (""))

  (load "build-lib.scm")

  (define *gx-modules*
    (map (lambda (modf) (string-append modf ".scm"))
         '("gx-gambc"
           "gx-gambc0"
           "gx-gambc1"
           "gx-gambc2")))

  (define (runtime-smp?)
    (not (##vector-ref (thread-thread-group ##primordial-thread) 3)))

  (define (update-gx-version)
    (let* ((gx-version-path "gx-version.scm")
           (git-version
            (and (file-exists? "../../../.git")
                 (with-exception-catcher
                  (lambda (e) #f)
                  (lambda ()
                    (let* ((proc (open-process '(path: "git" arguments: ("describe" "--tags" "--always")
                                                       show-console: #f)))
                           (version (read-line proc))
                           (status (process-status proc)))
                      (close-port proc)
                      (and (zero? status)
                           (string? version) ;; (not (eof-object? version))
                           version))))))
           (gx-version-text
            (and git-version
                 (string-append "(define (gerbil-version-string) \"" git-version "\")\n")))
           (previous-gx-version-text
            (and gx-version-text ;; no need to compute it if no current version to replace it with
                 (file-exists? gx-version-path)
                 (call-with-input-file `(path: ,gx-version-path)
                   (lambda (port) (read-line port #f))))))
      (if (and gx-version-text (not (equal? gx-version-text previous-gx-version-text)))
        (call-with-output-file `(path: ,gx-version-path create: maybe append: #f truncate: #t)
          (lambda (port) (display gx-version-text port))))))

  <<runtime-build-main>>
#+end_src

* /File/ =gx-gambc2.scm=

#+HEADER: :tangle ../gerbil/src/gerbil/runtime/gx-gambc2.scm
#+begin_src scheme :noweb yes
  ;;; -*- Gerbil -*-
  ;;; (C) vyzo at hackzen.org
  ;;; Gerbil stage0 -- Gambit-C host compiler
  (##namespace (""))
  ;; (include "gx-gambc#.scm")

  (declare
    (block)
    (standard-bindings)
    (extended-bindings))
  ;; (declare (not safe))

  ;; shims to make things vectors
  <<_gx#vector>>

  ;; core [top] syntax -> gambit runtime compiler
  (define-macro (%AST? e)
    `(##structure-instance-of? ,e 'gerbil#AST::t))

  (define-macro (%AST-e e)
    `(##unchecked-structure-ref ,e 1 AST::t #f))

  (define-macro (%AST-source e)
    `(##unchecked-structure-ref ,e 2 AST::t #f))

  (define (&SRC e #!optional (src-stx #f))
    (cond
     ((or (pair? e) (symbol? e))
      (##make-source e (and (%AST? src-stx) (&locat (%AST-source src-stx)))))
     ((%AST? e)
      (##make-source (%AST-e e) (&locat (%AST-source e))))
     (else
      (error "BUG! Cannot sourcify object" e))))

  (define (&locat loc)
    (and (##locat? loc) loc))

  (define (_gx#check-values obj k)
    (let ((count (values-count obj)))
      (unless (fx= count k)
        (error (if (fx< count k)
                 "Too few values for context"
                 "Too many values for context")
          (if (##values? obj) (##values->list obj) obj)
          k))))

  (define-macro (%&syntax-e obj)
    `(_gx#vector-ref ,obj 1))

  (define (_gx#compile stx)
    (core-ast-case stx ()
      ((form . _)
       (cond
        ((&core-resolve form)
         => (lambda (bind)
              ((%&syntax-e bind) stx)))
        (else
         (_gx#raise-syntax-error #f "Bad syntax" stx form))))))

  (define (_gx#compile-error stx #!optional (detail #f))
    (_gx#raise-syntax-error 'compile "Bad syntax; cannot compile" stx detail))

  (define (_gx#compile-ignore% stx)
    (&SRC '(##void) stx))

  (define (_gx#compile-begin% stx)
    (core-ast-case stx ()
      ((_ . body)
       (&SRC (cons '##begin (map _gx#compile body)) stx))))

  (define (_gx#compile-begin-foreign% stx)
    (core-ast-case stx ()
      ((_ . body)
       (&SRC (cons '##begin (&AST->datum body)) stx))))

  (define (_gx#compile-import% stx)
    (core-ast-case stx ()
      ((_ . body)
       (&SRC `(_gx#eval-import (##quote ,body)) stx))))

  (define (_gx#compile-begin-annotation% stx)
    (core-ast-case stx ()
      ((_ ann expr)
       (_gx#compile expr))))

  (define (_gx#compile-define-values% stx)
    (core-ast-case stx ()
      ((_ hd expr)
       (core-ast-case hd ()
         ((#f)
          (_gx#compile expr))
         ((id)
          (&SRC
           `(##define ,(&SRC id)
                      ,(_gx#compile expr))
           stx))
         (else
          (let* ((ids hd)
                 (len (length ids))
                 (tmp (&SRC (gensym))))
            (&SRC
             `(##begin
               ,(&SRC `(##define ,tmp ,(_gx#compile expr)) stx)
               ,(&SRC `(_gx#check-values ,tmp ,len) stx)
               ,@(filter-map
                  (lambda (id k)
                    (and (&AST-e id)
                         (&SRC
                          `(##define ,(&SRC id)
                             )
                          stx)))
                  ids (iota len)))
             stx)))))))

  (define (_gx#compile-head-id e)
    (&SRC (if (&AST-e e) e (gensym))))

  (define (_gx#compile-lambda-head hd)
    (let recur ((rest hd))
      (core-ast-case rest ()
        ((hd . rest)
         (cons (_gx#compile-head-id hd)
               (recur rest)))
        (() '())
        (tail
         (_gx#compile-head-id tail)))))

  (define (_gx#compile-lambda% stx)
    (core-ast-case stx ()
      ((_ hd body)
       (&SRC
        `(##lambda ,(_gx#compile-lambda-head hd)
              ,(_gx#compile body))
        stx))))

  (define (_gx#compile-case-lambda% stx)
    (define (variadic? hd)
      (core-ast-case hd ()
        ((_ . rest)
         (variadic? rest))
        (() #f)
        (else #t)))

    (define (arity hd)
      (let lp ((rest hd) (k 0))
        (core-ast-case rest ()
          ((_ . rest)
           (lp rest (fx1+ k)))
          (else k))))

    (define (generate rest args len)
      (core-ast-case rest ()
        ((clause . rest)
         (core-ast-case clause ()
           ((hd _)
            (let ((clen (arity hd))
                  (cmp (if (variadic? hd) 'fx>= 'fx=)))
              (&SRC
               `(##if (,cmp ,len ,clen)
                      ,(&SRC
                        `(##apply ,(_gx#compile-lambda% (cons '%#lambda clause))
                                  ,args)
                        stx)
                      ,(generate rest args len))
               stx)))))
        (else
         (&SRC `(error "No clause matching arguments" ,args) stx))))

    (core-ast-case stx ()
      ((_ clause)
       (_gx#compile-lambda% (cons '%#lambda clause)))
      ((_ . clauses)
       (let ((args (&SRC (gensym) stx))
             (len  (&SRC (gensym) stx)))
         (&SRC
          `(##lambda ,args
                ,(&SRC
                  `(##let ((,len ,(&SRC `(##length ,args) stx)))
                          ,(generate clauses args len))
                  stx))
          stx)))))

  (define (_gx#compile-let-form stx compile-simple compile-values)
    (define (simple-bind? hd)
      (core-match hd
        ((id) #t)
        (#f #t)
        (else #f)))

    (define (car-e hd)
      (if (pair? hd) (car hd) hd))

    (core-ast-case stx ()
       ((_ () body)
        (_gx#compile body))
       ((_ hd body)
        (let* ((hd-ids (map (lambda (bind)
                              (core-ast-case bind ()
                                ((ids _) ids)))
                            hd))
               (exprs  (map (lambda (bind)
                              (core-ast-case bind ()
                                ((_ expr) (_gx#compile expr))))
                            hd))
               (body   (_gx#compile body)))
          (if (andmap simple-bind? hd-ids)
            (compile-simple (map car-e hd-ids) exprs body)
            (compile-values hd-ids exprs body))))))


  (define (_gx#compile-let-values% stx)
    (define (compile-simple hd-ids exprs body)
      (&SRC
       `(##let ,(map list (map _gx#compile-head-id hd-ids) exprs)
               ,body)
       stx))

    (define (compile-values hd-ids exprs body)
      (let lp ((rest hd-ids) (exprs exprs) (bind '()) (post '()))
        (core-match rest
          (((id) . rest)
           (lp rest (cdr exprs)
               (cons `(,(_gx#compile-head-id id) ,(car exprs)) bind)
               post))
          ((hd . rest)
           (cond
            ((&AST-id? hd)
             (lp rest (cdr exprs)
                 (cons `(,(_gx#compile-head-id hd) (values->list ,(car exprs)))
                       bind)
                 post))
            ((list? hd)
             (let* ((len (length hd))
                    (tmp (&SRC (gensym))))
               (lp rest (cdr exprs)
                   (cons `(,tmp ,(car exprs)) bind)
                   (cons (cons* tmp len
                                (filter-map (lambda (id k)
                                              (and (&AST-e id) (cons (&SRC id) k)))
                                            hd (iota len)))
                         post))))
            (else
             (_gx#compile-error stx hd))))
          (else
           (&SRC
            `(##let ,(reverse bind)
                    ,(compile-post post body))
            stx)))))

    (define (compile-post post body)
      (let lp ((rest post) (check '()) (bind '()))
        (core-match rest
          (((tmp len . init) . rest)
           (lp rest
               (cons (&SRC `(_gx#check-values ,tmp ,len) stx) check)
               (foldr (lambda (hd r)
                        (core-match hd
                          ((id . k)
                           (cons `(,id (##vector-ref ,tmp ,k)) r))))
                      bind init)))
          (else
           (&SRC
            `(##begin ,@check
                      ,(&SRC `(##let ,bind ,body) stx))
            stx)))))

    (_gx#compile-let-form stx compile-simple compile-values))

  (define (_gx#compile-letrec-values% stx)
    (define (compile-simple hd-ids exprs body)
      (&SRC
       `(##letrec ,(map list (map _gx#compile-head-id hd-ids) exprs)
                  ,body)
       stx))

    (define (compile-values hd-ids exprs body)
      (let lp ((rest hd-ids) (exprs exprs) (pre '()) (bind '()) (post '()))
        (core-match rest
          (((id) . rest)
           (lp rest (cdr exprs)
               pre
               (cons `(,(_gx#compile-head-id id) ,(car exprs)) bind)
               post))
          ((hd . rest)
           (cond
            ((&AST-id? hd)
             (lp rest (cdr exprs)
                 pre
                 (cons `(,(_gx#compile-head-id hd) (values->list ,(car exprs)))
                       bind)
                 post))
            ((list? hd)
             (let* ((len (length hd))
                    (tmp (&SRC (gensym))))
               (lp rest (cdr exprs)
                   (foldl (lambda (id r)
                            (if (&AST-e id) (cons `(,(&SRC id) #!void) r) r))
                          pre hd)
                   (cons `(,tmp ,(car exprs)) bind)
                   (cons (cons* tmp len
                                (filter-map (lambda (id k)
                                              (and (&AST-e id) (cons (&SRC id) k)))
                                            hd (iota len)))
                         post))))
            (else
             (_gx#compile-error stx hd))))
          (else
           (compile-inner pre bind post body)))))

    (define (compile-inner pre bind post body)
      (if (null? pre)
        (compile-bind bind post body)
        (&SRC
         `(##let ,(reverse pre)
                 ,(compile-bind bind post body))
         stx)))

    (define (compile-bind bind post body)
      (&SRC
       `(##letrec ,(reverse bind)
                  ,(compile-post post body))
       stx))

    (define (compile-post post body)
      (let lp ((rest post) (check '()) (bind '()))
        (core-match rest
          (((tmp len . init) . rest)
           (lp rest
               (cons (&SRC `(_gx#check-values ,tmp ,len) stx) check)
               (foldr (lambda (hd r)
                        (core-match hd
                          ((id . k)
                           (cons `(##set! ,id (##vector-ref ,tmp ,k)) r))))
                      bind init)))
          (else
           (&SRC
            `(##begin ,@check ,@bind ,body)
            stx)))))

    (_gx#compile-let-form stx compile-simple compile-values))

  (define (_gx#compile-letrec*-values% stx)
    (define (compile-simple hd-ids exprs body)
      (&SRC
       `(##letrec* ,(map list (map _gx#compile-head-id hd-ids) exprs)
                   ,body)
       stx))

    (define (compile-values hd-ids exprs body)
      (let lp ((rest hd-ids) (exprs exprs) (bind '()) (post '()))
        (core-match rest
          (((hd) . rest)
           (if (&AST-id? hd)
             (let ((id (&SRC hd)))
               (lp rest (cdr exprs)
                   (cons `(,id #!void) bind)
                   (cons `(,id ,(car exprs)) post)))
             (lp rest (cdr exprs) bind
                 (cons `(#f ,(car exprs)) post))))
          ((hd . rest)
           (cond
            ((&AST-id? hd)
             (let ((id (&SRC hd)))
               (lp rest (cdr exprs)
                   (cons `(,id #!void) bind)
                   (cons `(,id (values->list ,(car exprs))) post))))
            ((not (&AST-e hd))
             (lp rest (cdr exprs) bind
                 (cons `(#f ,(car exprs)) post)))
            ((list? hd)
             (let* ((len (length hd))
                    (tmp (&SRC (gensym))))
               (lp rest (cdr exprs)
                   (foldl (lambda (id r)
                            (if (&AST-e id) (cons `(,(&SRC id) #!void) r) r))
                          bind hd)
                   (cons (cons* tmp (car exprs) len
                                (filter-map (lambda (id k)
                                              (and (&AST-e id) (cons (&SRC id) k)))
                                            hd (iota len)))
                         post))))
            (else
             (_gx#compile-error stx hd))))
          (else
           (compile-bind bind post body)))))

    (define (compile-bind bind post body)
      (&SRC
       `(##let ,(reverse bind)
               ,(compile-post post body))
       stx))

    (define (compile-post post body)
      (&SRC
       `(##begin
         ,@(foldl
             (lambda (hd r)
               (core-match hd
                 ((#f expr)
                  (cons expr r))
                 ((id expr)
                  (cons (&SRC `(##set! ,id ,expr) stx) r))
                 ((tmp expr len . init)
                  (cons
                   (&SRC
                    `(##let ((,tmp ,expr))
                            ,(&SRC `(_gx#check-values ,tmp ,len) stx)
                            ,@(map (lambda (hd)
                                     (core-match hd
                                       ((id . k)
                                        (&SRC
                                         `(##set! ,id (##vector-ref ,tmp ,k))
                                         stx))))
                                   init))
                    stx)
                   r))))
             (list body) post))
       stx))

    (_gx#compile-let-form stx compile-simple compile-values))

  (define (_gx#compile-call% stx)
    (core-ast-case stx ()
      ((_ rator . rands)
       (&SRC (cons (_gx#compile rator)
                   (map _gx#compile rands))
             stx))))

  (define (_gx#compile-ref% stx)
    (core-ast-case stx ()
      ((_ id)
       (&SRC id stx))))

  (define (_gx#compile-setq% stx)
    (core-ast-case stx ()
      ((_ id expr)
       (&SRC `(##set! ,(&SRC id stx) ,(_gx#compile expr)) stx))))

  (define (_gx#compile-if% stx)
    (core-ast-case stx ()
      ((_ p t f)
       (&SRC `(##if ,(_gx#compile p)
                    ,(_gx#compile t)
                    ,(_gx#compile f))
             stx))))

  (define (_gx#compile-quote% stx)
    (core-ast-case stx ()
      ((_ e) (&SRC `(##quote ,(&AST->datum e)) stx))))

  (define (_gx#compile-quote-syntax% stx)
    (core-ast-case stx ()
      ((_ e) (&SRC `(##quote ,e) stx))))

  (define-core-forms
    (%#begin            special: compile-begin%)
    (%#begin-syntax     special: compile-ignore%)
    (%#begin-foreign    special: compile-begin-foreign%)
    (%#module           special: compile-ignore%)
    (%#import           special: compile-import%)
    (%#export           special: compile-ignore%)
    (%#provide          special: compile-ignore%)
    (%#define-values    special: compile-define-values%)
    (%#define-syntax    special: compile-ignore%)
    (%#define-alias     special: compile-ignore%)
    (%#define-runtime   special: compile-ignore%)
    (%#extern           special: compile-ignore%)
    (%#declare          special: compile-ignore%)
    (%#begin-annotation expr:    compile-begin-annotation%)
    (%#quote            expr:    compile-quote%)
    (%#quote-syntax     expr:    compile-quote-syntax%)
    (%#lambda                expr:    compile-lambda%)
    (%#case-lambda           expr:    compile-case-lambda%)
    (%#let-values       expr:    compile-let-values%)
    (%#letrec-values    expr:    compile-letrec-values%)
    (%#letrec*-values   expr:    compile-letrec*-values%)
    (%#call             expr:    compile-call%)
    (%#if               expr:    compile-if%)
    (%#ref              expr:    compile-ref%)
    (%#set!             expr:    compile-setq%)
    ;; intermediate -- meta-compiler must compile
    (%#cond-expand      #f)
    (%#include          #f)
    (%#let-syntax       #f)
    (%#letrec-syntax    #f))

#+end_src
* /File/ =gerbil/src/gerbil/runtime/gx-gambc#.scm=
#+HEADER: :tangle ../gerbil/src/gerbil/runtime/gx-gambc#.scm
#+begin_src scheme :noweb yes
  ;;; -*- Scheme -*-
  ;;; (C) vyzo at hackzen.org
  ;;; Gerbil stage0 -- Gambit-C macros
  (##namespace (""))
  (include "~~lib/_gambit#.scm")

  ;;; shims to ensure inlining of low level primitives
  (define-macro (%%apply . args)
    `(let () (declare (not safe)) (##apply ,@args)))
  (define-macro (%%car . args)
    `(let () (declare (not safe)) (##car ,@args)))
  (define-macro (%%cdr . args)
    `(let () (declare (not safe)) (##cdr ,@args)))
  (define-macro (%%set-car! . args)
    `(let () (declare (not safe)) (##set-car! ,@args)))
  (define-macro (%%set-cdr! . args)
    `(let () (declare (not safe)) (##set-cdr! ,@args)))
  <<%%vectors>>
  (define-macro (%%string-ref . args)
    `(let () (declare (not safe)) (##string-ref ,@args)))
  (define-macro (%%string-set! . args)
    `(let () (declare (not safe)) (##string-set! ,@args)))
  (define-macro (%%string-length . args)
    `(let () (declare (not safe)) (##string-length ,@args)))
  (define-macro (%%string-append . args)
    `(let () (declare (not safe)) (##string-append ,@args)))
  (define-macro (%%substring . args)
    `(let () (declare (not safe)) (##substring ,@args)))
  (define-macro (%%substring-move! . args)
    `(let () (declare (not safe)) (##substring-move! ,@args)))
  (define-macro (%%make-vector . args)
    `(let () (declare (not safe)) (##make-vector ,@args)))
  (define-macro (%%vector->list . args)
    `(let () (declare (not safe)) (##vector->list ,@args)))
  (define-macro (%%values? . args)
    `(let () (declare (not safe)) (##values? ,@args)))
  (define-macro (%%values-length . args)
    `(let () (declare (not safe)) (##values-length ,@args)))
  (define-macro (%%values-ref . args)
    `(let () (declare (not safe)) (##values-ref ,@args)))
  (define-macro (%%values->list . args)
    `(let () (declare (not safe)) (##values->list ,@args)))
  (define-macro (%%fx+ . args)
    `(let () (declare (not safe)) (##fx+ ,@args)))
  (define-macro (%%fx- . args)
    `(let () (declare (not safe)) (##fx- ,@args)))
  (define-macro (%%fx= . args)
    `(let () (declare (not safe)) (##fx= ,@args)))
  (define-macro (%%fx< . args)
    `(let () (declare (not safe)) (##fx< ,@args)))
  (define-macro (%%fx<= . args)
    `(let () (declare (not safe)) (##fx<= ,@args)))
  (define-macro (%%fx> . args)
    `(let () (declare (not safe)) (##fx> ,@args)))
  (define-macro (%%fx>= . args)
    `(let () (declare (not safe)) (##fx>= ,@args)))
  (define-macro (%%fxior . args)
    `(let () (declare (not safe)) (##fxior ,@args)))
  (define-macro (%%fxand . args)
    `(let () (declare (not safe)) (##fxand ,@args)))
  (define-macro (%%fxmodulo . args)
    `(let () (declare (not safe)) (##fxmodulo ,@args)))
  (define-macro (%%fxarithmetic-shift . args)
    `(let () (declare (not safe)) (##fxarithmetic-shift ,@args)))
  (define-macro (%%fxzero? . args)
    `(let () (declare (not safe)) (##fxzero? ,@args)))
  (define-macro (%%fxbit-set? . args)
    `(let () (declare (not safe)) (##fxbit-set? ,@args)))
  (define-macro (%%fl> . args)
    `(let () (declare (not safe)) (##fl> ,@args)))
  (define-macro (%%type . args)
    `(let () (declare (not safe)) (##type ,@args)))
  (define-macro (%%type? . args)
    `(let () (declare (not safe)) (##type? ,@args)))
  (define-macro (%%type-id . args)
    `(let () (declare (not safe)) (##type-id ,@args)))
  (define-macro (%%type-super . args)
    `(let () (declare (not safe)) (##type-super ,@args)))
  (define-macro (%%type-flags . args)
    `(let () (declare (not safe)) (##type-flags ,@args)))
  (define-macro (%%structure . args)
    `(let () (declare (not safe)) (##structure ,@args)))
  (define-macro (%%make-structure . args)
    `(let () (declare (not safe)) (##make-structure ,@args)))
  (define-macro (%%structure-length . args)
    `(let () (declare (not safe)) (##structure-length ,@args)))
  (define-macro (%%structure-instance-of? . args)
    `(let () (declare (not safe)) (##structure-instance-of? ,@args)))
  (define-macro (%%structure-direct-instance-of? . args)
    `(let () (declare (not safe)) (##structure-direct-instance-of? ,@args)))
  (define-macro (%%structure-ref . args)
    `(let () (declare (not safe)) (##structure-ref ,@args)))
  (define-macro (%%structure-set! . args)
    `(let () (declare (not safe)) (##structure-set! ,@args)))
  (define-macro (%%unchecked-structure-ref . args)
    `(let () (declare (not safe)) (##unchecked-structure-ref ,@args)))
  (define-macro (%%unchecked-structure-set! . args)
    `(let () (declare (not safe)) (##unchecked-structure-set! ,@args)))
  (define-macro (%%subtype-set! . args)
    `(let () (declare (not safe)) (##subtype-set! ,@args)))

  ;; conditional evaluation
  (define-macro (eval-when expr . forms)
    (if (eval expr)
      `(begin ,@forms)
      '(begin)))

  (define-macro (eval-if test then else)
    (if (eval test)
      `(begin ,then)
      `(begin ,else)))

  (define-macro (eval-if-bound symbol then else)
    (let ((bound?
           (with-exception-catcher
            (lambda (e) #f)
            (lambda () (procedure? (eval symbol))))))
      (if bound? then else)))

  ;; when and unless
  (define-macro (when condition . body)
    `(if ,condition (begin ,@body) #!void))
  (define-macro (unless condition . body)
    `(if ,condition #!void (begin ,@body)))

  ;; core-match; quite older code
  (define-macro (core-match expr . cases)
    (let (($e (gensym '$e)))
      `(let ((,$e ,expr))
         (core-match~ ,$e ,@cases))))

  (define-macro (core-match~ tgt . cases)
    (define recur
      (lambda (tgt hd K E)
        (cond
         ((null? hd)
          `(if (null? ,tgt) ,K ,E))
         ((symbol? hd)
          (if (or (eq? hd '_)
                  (eq? hd 'else))
            K
            `(let ((,hd ,tgt)) ,K)))
         ((or (number? hd)
              (string? hd)
              (char? hd)
              (keyword? hd)
              (boolean? hd)
              (eq? hd #!void))
          `(if (equal? ,tgt ,hd) ,K ,E))
         ((quote? hd)
          `(if (eq? ,tgt (quote ,(cadr hd)))
             ,K ,E))
         ((predicate? hd)
          `(if (,(cadr hd) ,tgt) ,K ,E))
         ((predicate-rec? hd)
          `(if (,(cadr hd) ,tgt)
             ,(recur tgt (caddr hd) K E)
             ,E))
         ((pair? hd)
          (let* (($hd (gensym '$hd))
                 ($tl (gensym '$tl))
                 (K* (recur $tl (cdr hd) K E)))
            `(if (pair? ,tgt)
               (let* ((,$hd (%%car ,tgt))
                      (,$tl (%%cdr ,tgt)))
                 ,(recur $hd (car hd) K* E))
               ,E)))
         (else
          (error "core-match: bad pattern" hd)))))

    (define quote?
      (lambda (hd)
        (and (pair? hd)
             (eq? (car hd) 'quote)
             (pair? (cdr hd)))))

    (define predicate?
      (lambda (hd)
        (and (list? hd)
             (or (and (= (length hd) 2)
                      (eq? (car hd) '?))
                 (and (= (length hd) 3)
                      (eq? (car hd) '?)
                      (eq? (caddr hd) '_))))))

    (define predicate-rec?
      (lambda (hd)
        (and (list? hd)
             (= (length hd) 3)
             (eq? (car hd) '?))))

    (if (null? cases)
      `(error "core-match: no clause matching" ,tgt)
      (let* ((e    (car cases))
             (hd   (car e))
             (body (cdr e))
             (rest (cdr cases))
             (K    `(begin ,@body))
             (E    `(core-match~ ,tgt ,@rest))
             ($E   (gensym '$E)))
        `(let ((,$E (lambda () ,E)))
           ,(recur tgt hd K (list $E))))))

  (define-macro (define-struct hd fields . opts)
    (define (generate id super)
      (let* ((pre  (symbol->string id))
             (type (string->symbol (string-append pre "::t")))
             (is?  (string->symbol (string-append pre "?")))
             (make (string->symbol (string-append "make-" pre)))
             (pref (map (lambda (field)
                          (string-append pre "-" (symbol->string field)))
                        fields))
             (getf (map string->symbol pref))
             (setf (map (lambda (pref)
                          (string->symbol (string-append pref "-set!")))
                        pref))
             (off  (let lp ((rest fields) (n 0) (r '()))
                     (core-match rest
                       ((_ . rest)
                        (lp rest (+ n 1) (cons n r)))
                       (else
                        (reverse r)))))
             (tmp  (gensym))
             (type-id
              `(quote ,(or (getopt id:) (gensym id))))
             (type-name
              `(quote ,(or (getopt name:) id)))
             (type-ctor
              `(quote ,(or (getopt constructor:) #f)))
             (type-len
              (length fields)))
        `(begin
           (define ,type
             (make-struct-type ,type-id ,super ,type-len
                               ,type-name '() ,type-ctor))
           (define ,is?
             (make-struct-predicate ,type))
           (define ,make
             (lambda ,tmp
               (apply make-struct-instance ,type ,tmp)))
           ,@(map (lambda (getf off)
                    `(define ,getf
                       (make-struct-field-accessor ,type ,off)))
                  getf off)
           ,@(map (lambda (setf off)
                    `(define ,setf
                       (make-struct-field-mutator ,type ,off)))
                  setf off))))

    (define (getopt key)
      (let lp ((rest opts))
        (core-match rest
          ((hd val . rest)
           (if (eq? key hd) val
               (lp rest)))
          (else #f))))

    (core-match hd
      (((? symbol? id) super)
       (generate id super))
      ((? symbol? id)
       (generate id #f))))

  (define-macro (let-values hd . body)
    (let recur ((rest hd))
      (core-match rest
        (((hd expr) . rest)
         `(call-with-values (lambda () ,expr)
            (lambda ,hd ,(recur rest))))
        (else
         `(let () ,@body)))))

  ;; :<core> macros
  (define-macro (define-core id impl bind!)
    (let ((core-id (string->symbol (string-append "_gx#" (symbol->string id)))))
      `(begin
         (define ,core-id ,impl)
         (,bind! ,core-id))))

  (define-macro (define-core-macro hd . body)
    (define (generate id args body bind!)
      (let ((impl (gensym))
            (stx (gensym)))
         `(define-core ,id
            (lambda ,args ,@body)
            (lambda (,impl)
              (,bind! (quote ,id)
                      (lambda (,stx) (&AST (,impl ,stx) ,stx)))))))
    (core-match hd
      (special:
       (core-match body
         (((id . args) . body)
          (generate id args body '&core-bind-special-form!))))
      ((id . args)
       (generate id args body '&core-bind-macro!))))

  (define-macro (define-core-special-form hd . body)
    `(define-core-macro special: ,hd ,@body))

  (define-macro (define-core-syntax id expr)
    `(&core-bind-syntax! (quote ,id) ,expr))

  (define-macro (define-core-forms . body)
    (define (generate id compile make)
      (let ((eid (string->symbol
                  (string-append "_gx#" (symbol->string compile)))))
        `(&core-bind-syntax! (quote ,id) ,eid ,make)))

    (let lp ((rest body) (rbody '()))
      (core-match rest
        (((id expr: compile) . rest)
         (lp rest (cons (generate id compile 'make-&core-expression) rbody)))
        (((id special: compile) . rest)
         (lp rest (cons (generate id compile 'make-&core-special-form) rbody)))
        (((id #f) . rest)
         (lp rest (cons (generate id 'compile-error 'make-&core-form) rbody)))
        (() (cons 'begin rbody)))))

  (define-macro (core-ast-case expr . body)
    (let (($e (gensym '$e)))
      `(let ((,$e ,expr))
         (core-ast-case~ ,$e ,@body))))

  (define-macro (core-ast-case~ tgt kws . cases)
    (define (generate1 hd tgt K E)
      (core-match hd
        ((hd . rest)
         (let (($tgt (gensym '$tgt))
               ($hd  (gensym '$hd))
               ($tl  (gensym '$tl)))
           `(if (&AST-pair? ,tgt)
              (let* ((,$tgt (&AST-e ,tgt))
                     (,$hd  (%%car  ,$tgt))
                     (,$tl  (%%cdr  ,$tgt)))
                ,(generate1 hd $hd (generate1 rest $tl K E) E))
              ,E)))
        ((? symbol? id)
         (cond
          ((eq? id '_) K)
          ((memq id kws)
           `(if (and (&AST-id? ,tgt)
                     (eq? (&AST-e ,tgt) (quote ,id)))
              ,K ,E))
          (else
           `(let ((,id ,tgt)) ,K))))
        (else
         (let ((is? (cond
                     ((atom? hd)   'eq?)
                     ((number? hd) 'eqv?)
                     (else         'equal?))))
           `(if (,is? (&AST-e ,tgt) (quote ,hd))
              ,K ,E)))))

    (define (atom? e)
      (or (null? e)
          (char? e)
          (boolean? e)
          (keyword? e)
          (eq? e #!void)))

    (let recur ((rest cases))
      (core-match rest
        ((hd . rest)
         (let* (($E (gensym '$E))
                (E `(,$E)))
           `(let ((,$E (lambda () ,(recur rest))))
              ,(core-match hd
                 (('else . body)
                  `(begin ,@body))
                 ((pat expr)
                  (generate1 pat tgt expr E))
                 ((pat fender expr)
                  (generate1 pat tgt `(if ,fender ,expr ,E) E))))))
        (() `(_gx#raise-syntax-error #f "Bad syntax" ,tgt)))))
#+end_src
